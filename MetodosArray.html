<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>exemplo</title>
    <style>
        .centralizar{
            text-align: center;
        }
        .campos{
            background-color: bisque;
            height: auto;
            width: 50%;
            border-radius: 10px;
            box-shadow: 5px 5px 10px rgba(0, 0, 0, .6);
            padding: 10px;
            margin: auto;
            position: relative;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>  
    <header>
        <p class="centralizar">Alguns métodos para arrays</p>
    </header>
    <section>
        <div class="campos" id="res">

        </div>
    </section>
    <footer>
        <p class="centralizar"> &copy; Vinicius Cavalcante</p>
    </footer>
    <script>
        var vet = [2, 4, 10, 24, 54, 4, false]
        var res = document.getElementById('res');

        res.innerHTML += vet.every(function elemPar(e,i,a){return e%2 == 0 }) + '<br>'//Método every retorna true se todo elemento do array é validado pela função, e false caso qualquer elemento seja invalido.

        res.innerHTML += vet.filter(function maiorDez(e,i,a){return e >= 10}) + '<br>'//Método filter retorna os elemento do array que validam a função.

        res.innerHTML += vet.map(function multiDez(e,i,a){return  e*10}) + '<br>' //Método map modifica os elementos do array conforme especificado na função callback e grava os resultados em outro array

        res.innerHTML += vet.some(function maiorCem(e,i,a){return typeof e == "boolean"}) + '<br>' //Método some é parecido com o método every, mas ao encontrar qualquer elemento que resulte em true na função callback eu retorno é true, somente se nenhum elemento satisfazer a função callback é retornado false.

        /* Os Métodos acima precisam de uma função com 3 argumentos, elemento, indice e o array a ser percorrido respectivamente, além destes existem mais alguns métodos de array que seguem essa construção. Nenhum deles modifica o array original se necessario criara um novo*/

        res.innerHTML += vet.indexOf(4) + '<br>';
        res.innerHTML += vet.indexOf('10') + '<br>'; //O método indexOf retorna o indice onde foi encontrado o dado passado. Este método repeita a tipagem de dado, Caso inserido indexOf('10') ele procurara por uma string de texto 10. Caso não encontrado o dado solicitado o método retorna -1

        res.innerHTML += vet.lastIndexOf(4) + '<br>'; //O método lastIndexOf segue a mesma estrutura do indexOf e admite os mesmos argumentos. A diferença dele é que retorna o último indice em que aparece o dado solicitado

        res.innerHTML += vet.join() + '<br>';
        res.innerHTML += vet.join(' - ') + '<br>'; //O método join transforma o array em um string e admite um argumento opcional que serve como caractere separador, se nada for passado será utilizado como padrão a virgula.

        res.innerHTML += vet.pop() + '<br>'; //Método pop remove o ultimo elemento do array original e o retorna

        res.innerHTML += vet.push('passado', 43, true, [2,45]) + '<br>' //Método push adiciona todos elementos passados como argumentos ao final do array original e retorna o número final de elementos.
        
        res.innerHTML += vet.reverse() + '<br>'; //Método reverse inverte a ordem do array original

        res.innerHTML += vet.shift() + '<br>'; //Método shift remove o primeiro elemento do array e retorna o que sobrou

        res.innerHTML += vet.slice(4,7) + '<br>'; //Método slice retorna um subgrupo do array original. O retorno começa do indice passado como primeiro argumento e termina no indice passado como segundo argumento (se houver)

    </script>
</body>
</html>